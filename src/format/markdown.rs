//! Markdown output format for abyss

use anyhow::Result;
use std::io::Write;
use std::path::{Path, PathBuf};

use super::Formatter;

pub struct MarkdownFormatter;

impl Formatter for MarkdownFormatter {
    fn write_header(
        &mut self,
        output: &mut dyn Write,
        token_count: Option<usize>,
        prompt: &Option<String>,
    ) -> Result<()> {
        writeln!(output, "# Repository Context")?;
        writeln!(output)?;
        if let Some(p) = prompt {
            writeln!(output, "> **Instruction**")?;
            writeln!(output, "> {}", p.replace("\n", "\n> "))?; // Quote the prompt
            writeln!(output)?;
        }
        if let Some(count) = token_count {
            writeln!(output, "> Total tokens: {}", count)?;
            writeln!(output)?;
        }
        Ok(())
    }

    fn write_directory_structure(
        &mut self,
        output: &mut dyn Write,
        files: &[PathBuf],
        repo_root: &Path,
    ) -> Result<()> {
        writeln!(output, "## Directory Structure")?;
        writeln!(output)?;
        writeln!(output, "```")?;
        for path in files {
            let relative = path.strip_prefix(repo_root).unwrap_or(path);
            writeln!(output, "{}", relative.display())?;
        }
        writeln!(output, "```")?;
        writeln!(output)?;
        Ok(())
    }

    fn write_file(
        &mut self,
        output: &mut dyn Write,
        path: &Path,
        content: &str,
        repo_root: &Path,
    ) -> Result<()> {
        let relative = path.strip_prefix(repo_root).unwrap_or(path);
        let extension = path.extension().and_then(|e| e.to_str()).unwrap_or("");

        // Map extensions to markdown language hints
        let lang = match extension {
            "rs" => "rust",
            "py" => "python",
            "js" => "javascript",
            "ts" => "typescript",
            "go" => "go",
            "c" | "h" => "c",
            "cpp" | "hpp" | "cc" => "cpp",
            "java" => "java",
            "rb" => "ruby",
            "sh" => "bash",
            "yml" | "yaml" => "yaml",
            "json" => "json",
            "toml" => "toml",
            "md" => "markdown",
            "html" => "html",
            "css" => "css",
            "sql" => "sql",
            _ => "",
        };

        writeln!(output, "## {}", relative.display())?;
        writeln!(output)?;
        writeln!(output, "```{}", lang)?;
        writeln!(output, "{}", content)?;
        writeln!(output, "```")?;
        writeln!(output)?;
        Ok(())
    }

    fn write_footer(&mut self, output: &mut dyn Write) -> Result<()> {
        writeln!(output, "---")?;
        writeln!(output, "*Generated by abyss*")?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_markdown_file() {
        let mut output = Vec::new();
        let root = PathBuf::from("/repo");
        let path = PathBuf::from("/repo/src/main.rs");
        let mut formatter = MarkdownFormatter;

        formatter
            .write_file(&mut output, &path, "fn main() {}", &root)
            .unwrap();

        let result = String::from_utf8(output).unwrap();
        assert!(result.contains("## src/main.rs"));
        assert!(result.contains("```rust"));
        assert!(result.contains("fn main() {}"));
    }
}
